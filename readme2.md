# JWT + Cookies + Refresh (Конспект)

## Общая схема работы с регистрацией, логином и токенами
** Когда юзер входит на сайт всегда проверяю токеныи если он уже был зареганый и не вылогинивался то /api/me и если есть токен то запрос вернет данные пользователя а если нету токена тогда сделает рефреш токена.

1. **Регистрация**
   - Пользователь вводит email и пароль.
   - Сервер хеширует пароль и сохраняет пользователя в базе.
   - Создаётся confirmToken для подтверждения email(nodemailer).
   - Отправляется письмо с подтверждением через SMTP. Протокол отправки писем (Simple Mail Transfer Protocol).

2. **Подтверждение email**
   - Пользователь кликает на ссылку с токеном.
   - Сервер проверяет токен и помечает email как подтверждённый.

3. **Логин**
   - Пользователь вводит email и пароль.
   - Сервер проверяет хеш пароля в базе и подтверждение email.
   - Генерируются токены:
     - **Access Token** – короткоживущий, для авторизации запросов.
     - **Refresh Token** – долгоживущий, для обновления access.
   - Токены отправляются в **httpOnly cookies** | **httpOnly** – нельзя прочитать из JS, только сервером.

4. **Использование токенов**
   - /api/me - тоесть когда user залогинился и закрыл сайт не вылогинившись то при следующем входе мы не требуем  пользователя снова залогинится потому что в куках уже есть его токен поэтому иы сами подгружаем его данные with help этого запроса
   - `/api/me` – проверка текущего пользователя по access token.
   - Каждый запрос к защищённым данным проверяет access token.
   - Если access истёк → вызывается `/api/refresh`, чтобы получить новый access без участия пользователя.

5. **Silent Refresh (фоновые обновления)**
   - После логина или загрузки страницы фронт ставит таймер на обновление access перед истечением.
   - Если вкладка спит(браузер может остановить таймер) и таймер не сработал → используется перехватчик запросов на 401.

6. **Interceptor / fetch wrapper**
   - Если запрос возвращает 401 → вызываем `/api/refresh` → повторяем запрос.
   - Гарантирует, что пользователь никогда не потеряет сессию и не делает лишних действий.

7. **Logout**
   - Сервер удаляет cookies access и refresh.
   - Пользователь разлогинен, нужно снова логиниться.

## Полезные моменты

- `sameSite: "Strict"` – куки доступны только с твоего сайта.  
- `secure` – true только в продакшене (HTTPS).  
- `maxAge` – время жизни куки (access 15 мин, refresh 7 дней).  
- `RequestInit` – интерфейс параметров fetch (метод, headers, тело, куки и т.д.).

##Пример Silent Refresh in Frontend:

```javascript

import jwtDecode from "jwt-decode";

function startTokenRefreshTimer(accessToken: string) {
  const payload = jwtDecode<{ exp: number }>(accessToken); // exp = unix time (sec)
  const expiresInMs = payload.exp * 1000 - Date.now();
  const refreshBeforeMs = expiresInMs - 120 * 1000; // за 2 мин до конца

  if (refreshBeforeMs > 0) {
    setTimeout(async () => {
      await fetch("/api/refresh", { method: "POST", credentials: "include" });
      // получаем новый access cookie (сервер сам выставит)
      // Можно снова вызвать /api/me чтобы обновить данные
    }, refreshBeforeMs);
  }
}

```
